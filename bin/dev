#!/usr/bin/env ruby
require 'open3'

class DevTool
  MAIN_HELP_BANNER = <<HEREDOC
Execute various commands within the developer environment

Usage:
  dev [options] [COMMAND] [ARGS...]"
  dev -h|--help

Options:
  --verbose                 Show more output
  -v, --version             Print version and exit

Commands:
  help               Get help on a command
  update             Update Dash developer environment

HEREDOC

  OTHER_COMMANDS=%w{update}

  def initialize(args)
    if OTHER_COMMANDS.include?(args[0])
      send(args.shift.to_sym, args)
    else
      puts MAIN_HELP_BANNER
    end
  end

  def update(args)
    system('cd /usr/local/dev-env && git fetch && git reset --hard origin/master')
    system('ansible-playbook /usr/local/dev-env/ansible/mac.yml -i 127.0.0.1, --ask-become-pass --verbose')
  end

  # H.T. https://gist.github.com/lpar/1032297
  # Runs a specified shell command in a separate thread.
  # If it exceeds the given timeout in seconds, kills it.
  # Returns any output produced by the command (stdout or stderr) as a String.
  # Uses select to wait up to the tick length (in seconds) between
  # checks on the command's status
  #
  # If you've got a cleaner way of doing this, I'd be interested to see it.
  # If you think you can do it with Ruby's Timeout module, think again.
  #
  # This has been modified to have smaller sleeps. It may struggle with
  # commands that run for a very long time.
  def run_with_timeout(command, timeout, tick)
    output = ''
    begin
      # Start task in another thread, which spawns a process
      stdin, stderrout, thread = Open3.popen2e(command)
      # Get the pid of the spawned process
      pid = thread[:pid]
      start = Time.now

      while (Time.now - start) < timeout and thread.alive?
        # Wait up to `tick` seconds for output/error data
        select([stderrout], nil, nil, tick)
        # Try to read the data
        begin
          output << stderrout.read_nonblock(4096)
        rescue IO::WaitReadable
          # A read would block, so loop around for another select
        rescue EOFError
          # Command has completed, not really an error...
          break
        end
      end
      # Give Ruby time to clean up the other thread
      sleep 0.1

      if thread.alive?
        # We need to kill the process, because killing the thread leaves
        # the process alive but detached, annoyingly enough.
        Process.kill("TERM", pid)
        output = "Process timed out"
      end
    ensure
      stdin.close if stdin
      stderrout.close if stderrout
    end
    return output
  end
end

DevTool.new(ARGV) if __FILE__==$0
